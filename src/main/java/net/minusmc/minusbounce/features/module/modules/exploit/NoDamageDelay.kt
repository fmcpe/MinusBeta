// longathelstan tech?
package net.minusmc.minusbounce.features.module.modules.exploit

import net.minecraft.network.play.client.C02PacketUseEntity
import net.minecraft.network.play.client.C02PacketUseEntity.Action
import net.minusmc.minusbounce.event.EventState
import net.minusmc.minusbounce.event.EventTarget
import net.minusmc.minusbounce.event.PacketEvent
import net.minusmc.minusbounce.features.module.Module
import net.minusmc.minusbounce.features.module.ModuleCategory
import net.minusmc.minusbounce.features.module.ModuleInfo
import net.minusmc.minusbounce.value.BoolValue
import net.minusmc.minusbounce.value.IntegerValue

@ModuleInfo(name = "NoDamageDelay", description = "Removes the delay between attacks by managing attack packets.", category = ModuleCategory.EXPLOIT)
class NoDamageDelay : Module() {

    private val minPacketInterval = IntegerValue("minPacketInterval", 20, 0, 200, " ms") // Minimum interval between attack packets
    private val bypassAntiCheat = BoolValue("bypassAntiCheat", true) // Option to delay packets slightly for anti-cheat

    private var lastAttackTime: Long = 0

    @EventTarget
    fun onPacketSend(event: PacketEvent) {
        // Only act on outgoing attack packets
        if (event.eventType == EventState.SEND && event.packet is C02PacketUseEntity) {
            val packet = event.packet
            if (packet.action == Action.ATTACK) {
                val currentTime = System.currentTimeMillis()
                val interval = currentTime - lastAttackTime

                // Check if the interval is sufficient
                if (interval < minPacketInterval.get() && bypassAntiCheat.get()) {
                    event.cancelEvent() // Cancel if within min interval
                } else {
                    lastAttackTime = currentTime
                }
            }
        }
    }
}
